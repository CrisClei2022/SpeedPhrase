<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpeedPhrase</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; padding: 20px; }
    .video-container, .words-container, .formed-sentence, .controls { margin-top: 20px; }
    .word { display: inline-block; margin: 5px; padding: 10px 15px; background: #eee; border-radius: 5px; cursor: pointer; }
    .word.correct { background-color: #c8f7c5; }
    .word.incorrect { background-color: #f7c5c5; }
    .formed-sentence { font-weight: bold; margin-top: 10px; }
    button { margin-top: 10px; padding: 10px 20px; }
    .video-grid-container {
      padding: 20px;
    }
    
    .hidden {
      display: none;
    }

    .video-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }

    .video-card {
      background: #fff;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      width: 200px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }

    .video-card:hover {
      transform: scale(1.03);
    }
    
    .video-container {
    text-align: center;
    margin-top: 20px;
    }
    
    #video {
        max-width: 100%;
        height: auto;
        width: 70%;
    }
    
    /* Adicione este CSS dentro da sua tag <style> */

    .status-line {
      display: flex; /* Alinha o texto e o Ã­cone na mesma linha */
      align-items: center;
      gap: 8px; /* EspaÃ§amento entre o Ã­cone e o texto */
      font-weight: 500;
    }
    
    /* O pseudo-elemento ::before cria o Ã­cone dinamicamente */
    .status-line::before {
      content: ''; /* Ãcone vazio por padrÃ£o */
      font-size: 1.2em;
    }
    
    /* Classe para quando o turno estÃ¡ ATIVO */
    .status-line.turn-active {
      opacity: 1;
    }
    .status-line.turn-active::before {
      content: 'ğŸŸ¢'; /* Ãcone verde para turno ativo */
    }
    
    /* Classe para quando o turno estÃ¡ ESPERANDO (vez do oponente) */
    .status-line.turn-waiting {
      opacity: 0.6; /* Deixa o status um pouco apagado para indicar inatividade */
    }
    .status-line.turn-waiting::before {
      content: 'ğŸ”´'; /* Ãcone vermelho para turno em espera */
    }

  </style>
</head>
<body>

<main style="padding-bottom: 80px;">
<button id="testResultsBtn">Testar Tela de Resultados</button>
  <!-- Header fixo com navegaÃ§Ã£o
  Por que esta abordagem Ã© profissional:
  âœ… SeparaÃ§Ã£o de responsabilidades - Timer nÃ£o mistura com tÃ­tulo 
  âœ… Visual limpo - Badges discretos mas visÃ­veis 
  âœ… Responsivo - Se adapta a diferentes tamanhos de tela 
  âœ… Contextual - SÃ³ aparece quando relevante
  âœ… PadrÃ£o da indÃºstria - Similar a apps como Duolingo, Khan Academy
  O timer fica como um badge verde elegante ao lado do progresso, mantendo o header profissional e organizados.
  -->
<header id="mainHeader" class="main-header">
  <nav class="header-nav">
    <button id="backBtn" class="nav-button back-button hidden" onclick="NavigationController.goBack()">
      <span class="nav-icon">â†</span>
      <span class="nav-text">Voltar</span>
    </button>
    
    <button id="homeBtn" class="nav-button home-button" onclick="NavigationController.goHome()">
      <span class="nav-icon">ğŸ </span>
      <span class="nav-text">Home</span>
    </button>
    
    <div class="header-center">
      <h1 id="headerTitle" class="header-title">SpeedPhrase</h1>
      
      <div id="exerciseStatus" class="exercise-status hidden">
        
        <div id="playerStatus" class="status-line">
          <span id="progressBadge" class="progress-badge"></span>
          <span id="timer" class="timer-badge"></span>
        </div>
        
        <div id="opponentStatus" class="status-line hidden">
          <span id="opponentProgressBadge" class="progress-badge"></span>
          <span id="opponentTimer" class="timer-badge"></span>
        </div>
        
      </div>
    </div>
    
    <button id="settingsBtn" class="nav-button settings-button" onclick="NavigationController.openSettings()">
      <span class="nav-icon">âš™ï¸</span>
    </button>
  </nav>
</header>
  
  <!-- SeÃ§Ã£o de seleÃ§Ã£o de modo de jogo -->
<section id="gameModeSection" class="game-mode-container">
  <h2>Escolha o modo de jogo</h2>
  <div class="mode-buttons">
    <button class="mode-button" onclick="selectGameMode('solo')">
      <span class="mode-icon">ğŸ¯</span>
      <span class="mode-title">Solo</span>
      <span class="mode-description">Jogue no seu prÃ³prio ritmo</span>
    </button>
    <button class="mode-button" onclick="selectGameMode('multiplayer')">
      <span class="mode-icon">ğŸ‘¥</span>
      <span class="mode-title">Multiplayer</span>
      <span class="mode-description">Desafie outros jogadores</span>
    </button>
  </div>
</section>
  
  <section id="avulsas-section" class="video-grid-container">
    <div id="avulsas-grid" class="video-grid"></div>
  </section>

  <section id="trilha-section" class="video-grid-container">
    <div id="trilha-grid" class="video-grid"></div>
  </section>

<!-- ====================== -->
<!-- Bloco HTML Multiplayer -->
<!-- ====================== -->
<section id="multiplayerLobbySection" style="text-align: center;">
  <!-- Apenas a visualizaÃ§Ã£o de partidas abertas -->
  <div id="joinGameView">
    <h2>Partidas Abertas</h2>
    <p>Entre em uma partida para desafiar outro jogador.</p>
    <div id="waitingGamesList" class="video-grid" style="margin-bottom: 20px;">
      <!-- Partidas abertas serÃ£o injetadas aqui -->
    </div>
  </div>
</section>

<section id="waitingScreen" class="waiting-room hidden" style="display: none;">
Â  <div class="waiting-message">
Â  Â  <h2>Aguardando Oponente</h2>
Â  Â  <p><strong id="waitingStatusMessage">Procurando um oponente...</strong></p>
Â  Â  <div class="waiting-animation">
Â  Â  Â  <div class="pulse"></div>
Â  Â  Â  <div class="pulse"></div>
Â  Â  Â  <div class="pulse"></div>
Â  Â  </div>
Â  </div>
</section>

<!-- ========================== -->
<!-- SeÃ§Ã£o de Resultados do Jogo -->
<!-- ========================== -->
<section id="gameResultsSection" class="section-container" style="display: none;">
  <h2 id="resultsTitle">Partida Finalizada!</h2>
  
  <div class="results-summary">
    <div id="playerResult" class="result-card">
      <h3 id="playerResultName">VocÃª</h3>
      <p class="performance-score" id="playerPerformanceScore">0%</p>
      <span id="playerWinnerBadge" class="winner-badge" style="display: none;">ğŸ† Vencedor</span>
    </div>
    
    <div class="versus-divider">VS</div>
    
    <div id="opponentResult" class="result-card">
      <h3 id="opponentResultName">Oponente</h3>
      <p class="performance-score" id="opponentPerformanceScore">0%</p>
      <span id="opponentWinnerBadge" class="winner-badge" style="display: none;">ğŸ† Vencedor</span>
    </div>
  </div>

  <div class="results-actions">
    <!-- PoderÃ­amos adicionar um botÃ£o de "Jogar Novamente" no futuro -->
  </div>
</section>

<!-- ========================== -->
<!-- SeÃ§Ã£o do vÃ­deo e controles -->
<!-- ========================== -->
  <section id="videoSection" style="margin-top: 0;">
    <div class="video-container">
      <video id="video" width="70%" height="340" controls>
        <source src="https://f005.backblazeb2.com/file/Avulsas/Im_Gonna_Be_-_500_Miles.mp4" type="video/mp4" />
      </video>
    </div>
    <div class="controls" style="margin-top: 10px;">
      <button onclick="playCurrentSubtitle()">â–¶ï¸ Tocar trecho</button>
    </div>
  </section>

  <!-- SeÃ§Ã£o da frase formada -->
  <section id="formedSentenceSection" style="margin-top: 20px;">
    <div class="formed-sentence" id="formedSentence"></div>
  </section>

  <!-- SeÃ§Ã£o das palavras embaralhadas -->
  <section id="shuffledWordsSection" style="margin-top: 20px;">
    <div class="words-container" id="shuffledWords"></div>
  </section>
</main>

<footer style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: #eee;
  padding: 10px;
  text-align: center;
  border-top: 1px solid #ccc;
  z-index: 1000;
">
  <nav>
    <button onclick="goToSearch()">ğŸ” Pesquisar</button>
    <button onclick="goToLessonCategory('avulsas')">ğŸ“‚ Avulsas</button>
    <button onclick="goToLessonCategory('trilha')">ğŸ›¤ï¸ Trilha</button>
  </nav>
</footer>

<!-- NOVO RODAPÃ‰ PARA O MULTIPLAYER -->
<footer id="multiplayerFooter" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: #fff;
  padding: 10px;
  text-align: center;
  border-top: 1px solid #ccc;
  z-index: 1001;
  display: none; /* ComeÃ§a oculto */
">
  <nav>
    <!-- Este botÃ£o agora navega para a tela de seleÃ§Ã£o de liÃ§Ã£o -->
    <button onclick="NavigationController.goToCreateGame()">â• Criar Nova Partida</button>
  </nav>
</footer>

<script src="https://cdn.jsdelivr.net/npm/appwrite@18.2.0"></script>
<script>
//=============================
// Estado da AplicaÃ§Ã£o
//=============================
let subtitles = [];
let currentIndex = 0;
let formedWords = [];
let currentGameMode = null;

//=============================
// Estado de Timer
//=============================
let startTime = 0;
let totalElapsedTime = 0;
let totalEstimatedTime = 0;
let timerInterval = null;

//=============================
// Estado de Multiplayer
//=============================
const serverState = {
  // Estado da conexÃ£o do WebSocket
  isConnected: false,
  
  // ID da sala (se houver)
  roomId: null,
  
  // Dados do oponente
  opponent: {
    id: null,
    name: null,
  },
  
  // Status atual do jogo
  status: 'idle', // Outros status: 'connecting', 'waitingForOpponent', 'inGame', 'disconnected'
  
  // Manipulador da conexÃ£o (WebSocket)
  socket: null
};

//=============================
// AppData - Dados Centralizados
//=============================
const AppData = {
    lessons: {
        avulsas: [{
            name: "Catbox - I'm Gonna Be - 500 Miles.mp4",
            srtUrl: "https://files.catbox.moe/wt145j.srt",
            videoUrl: "https://files.catbox.moe/8pzqza.mp4"
        }],
        trilha: [{
            name: "B.B. Chapter 1 - Welcome & Nationalities",
            videoUrl: "https://f005.backblazeb2.com/file/Avulsas/Im_Gonna_Be_-_500_Miles.mp4",
            srtUrl: "https://f005.backblazeb2.com/file/Avulsas/Im_Gonna_Be_-_500_Miles.srt"
        }]
    }
};

//=============================
// Game Mode Selection
//=============================
function selectGameMode(mode) {
    currentGameMode = mode;
    console.log(`Modo selecionado: ${mode}`);
    
    if (mode === 'multiplayer') {
        NavigationController.navigateTo('multiplayerLobby');
        NavigationController.showMultiplayerLobby();
    } else {
        NavigationController.navigateTo('lessonSelection');
        NavigationController.showLessonSelection();
    }
}

//=============================
// Navigation Controller
//=============================
const NavigationController = {
Â  Â  currentSection: 'gameMode',
Â  Â  currentLobbyView: 'joinGame',
Â  Â  navigationStack: [],

Â  Â  sectionConfig: {
Â  Â  Â  Â  gameMode: {
Â  Â  Â  Â  Â  Â  title: 'SpeedPhrase',
Â  Â  Â  Â  Â  Â  showBack: false,
Â  Â  Â  Â  Â  Â  showHome: true,
Â  Â  Â  Â  Â  Â  showFooter: false,
Â  Â  Â  Â  Â  Â  showMultiplayerFooter: false
Â  Â  Â  Â  },
Â  Â  Â  Â  lessonSelection: {
Â  Â  Â  Â  Â  Â  title: '',
Â  Â  Â  Â  Â  Â  showBack: true,
Â  Â  Â  Â  Â  Â  showHome: true,
Â  Â  Â  Â  Â  Â  showFooter: true,
Â  Â  Â  Â  Â  Â  showMultiplayerFooter: false
Â  Â  Â  Â  },
Â  Â  Â  Â  exercise: {
Â  Â  Â  Â  Â  Â  title: 'ExercÃ­cio',
Â  Â  Â  Â  Â  Â  showBack: true,
Â  Â  Â  Â  Â  Â  showHome: true,
Â  Â  Â  Â  Â  Â  showFooter: false,
Â  Â  Â  Â  Â  Â  showMultiplayerFooter: false
Â  Â  Â  Â  },
Â  Â  Â  Â  multiplayerLobby: {
Â  Â  Â  Â  Â  Â  title: 'Sala Multiplayer',
Â  Â  Â  Â  Â  Â  showBack: true,
Â  Â  Â  Â  Â  Â  showHome: true,
Â  Â  Â  Â  Â  Â  showFooter: false,
Â  Â  Â  Â  Â  Â  showMultiplayerFooter: true
Â  Â  Â  Â  },
Â  Â  Â  Â  waitingScreen: {
Â  Â  Â  Â  Â  Â  title: 'Aguardando Oponente',
Â  Â  Â  Â  Â  Â  showBack: true,
Â  Â  Â  Â  Â  Â  showHome: true,
Â  Â  Â  Â  Â  Â  showFooter: false,
Â  Â  Â  Â  Â  Â  showMultiplayerFooter: false
Â  Â  Â  Â  },
        gameResults: {
            title: 'Resultados da Partida',
            showBack: true, // Queremos o botÃ£o "Voltar" para o teste
            showHome: true,
            showFooter: false,
            showMultiplayerFooter: false
        }
Â  Â  },

Â  Â  updateMultiplayerFooterVisibility() {
Â  Â  Â  Â  const config = this.sectionConfig[this.currentSection];
Â  Â  Â  Â  const mpFooter = document.getElementById('multiplayerFooter');
Â  Â  Â  Â  if (mpFooter) {
Â  Â  Â  Â  Â  Â  if (config && config.showMultiplayerFooter) {
Â  Â  Â  Â  Â  Â  Â  Â  mpFooter.style.display = 'block';
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  mpFooter.style.display = 'none';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  },

Â  Â  navigateTo(section, pushToStack = true) {
Â  Â  Â  Â  if (this.currentSection === 'exercise' && section !== 'exercise') {
Â  Â  Â  Â  Â  Â  this.pauseAllResources();
Â  Â  Â  Â  Â  Â  this.hideExerciseStatus();
Â  Â  Â  Â  }

Â  Â  Â  Â  if (pushToStack && this.currentSection !== section) {
Â  Â  Â  Â  Â  Â  this.navigationStack.push(this.currentSection);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  this.currentSection = section;
Â  Â  Â  Â  this.updateHeader();
Â  Â  Â  Â  this.updateFooterVisibility();
Â  Â  Â  Â  this.updateMultiplayerFooterVisibility();
        
        // A Ãºnica responsabilidade dela Ã© chamar a funÃ§Ã£o que faz o trabalho pesado.
        this.navigateToSection(section);
    },

Â  Â  updateFooterVisibility() {
Â  Â  Â  Â  const config = this.sectionConfig[this.currentSection];
Â  Â  Â  Â  if (config && config.showFooter) {
Â  Â  Â  Â  Â  Â  showFooter();
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  hideFooter();
Â  Â  Â  Â  }
Â  Â  },

    goBack() {
        // Se estiver na tela de espera, cancele o matchmaking E HIDE A TELA
        if (this.currentSection === 'waitingScreen' && currentGameMode === 'multiplayer') {
            MultiplayerService.cancelMatchmaking();
        }
        this.hideWaitingScreen();

        if (this.currentSection === 'exercise') {
            this.pauseAllResources();
            this.hideExerciseStatus();
            
            const lastCategory = localStorage.getItem('lastLessonCategory') || 'avulsas';
            console.log(`â†©ï¸ Voltando de um exercÃ­cio para a categoria: ${lastCategory}`);
            
            if (lastCategory === 'trilha') {
                goToLessonCategory('trilha');
            } else {
                goToLessonCategory('avulsas');
            }
            return;
        }

        if (this.navigationStack.length > 0) {
            const previousSection = this.navigationStack.pop();
            if (previousSection === 'gameMode' && window.MultiplayerPlugin) {
                MultiplayerPlugin.hideLobby();
            }
            this.navigateToSection(previousSection);
        }
    },

    goHome() {
        // Se estiver em qualquer modo multiplayer, cancele o matchmaking E HIDE A TELA
        if (currentGameMode === 'multiplayer' && serverState.status !== 'idle') {
            MultiplayerService.cancelMatchmaking();
        }
        this.hideWaitingScreen();

        this.pauseAllResources();
        this.hideExerciseStatus();
        this.navigationStack = [];
        this.currentSection = 'gameMode';
        localStorage.removeItem('lastLessonCategory');
        this.showGameModeSelection();
        this.updateHeader();
    },

Â  Â  openSettings() {
Â  Â  Â  Â  alert('âš™ï¸ ConfiguraÃ§Ãµes em desenvolvimento');
Â  Â  },

Â  Â  updateHeader() {
Â  Â  Â  Â  const config = this.sectionConfig[this.currentSection];
Â  Â  Â  Â  if (!config) return;

Â  Â  Â  Â  let title = config.title;
Â  Â  Â  Â  if (this.currentSection === 'lessonSelection') {
Â  Â  Â  Â  Â  Â  title = this.getLessonSelectionTitle();
Â  Â  Â  Â  }

Â  Â  Â  Â  document.getElementById('headerTitle').textContent = title;

Â  Â  Â  Â  const backBtn = document.getElementById('backBtn');
Â  Â  Â  Â  if (config.showBack && this.navigationStack.length > 0) {
Â  Â  Â  Â  Â  Â  backBtn.classList.remove('hidden');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  backBtn.classList.add('hidden');
Â  Â  Â  Â  }
Â  Â  },

    navigateToSection(section) {
        switch (section) {
            case 'gameMode':
                this.showGameModeSelection();
                break;
            case 'lessonSelection':
                this.showLessonSelection();
                break;
            case 'gameResults':
                this.showGameResultsSection();
                break;
            default:
                this.showGameModeSelection();
        }
        this.currentSection = section;
        this.updateHeader();
        this.updateFooterVisibility();
        this.updateMultiplayerFooterVisibility();
    },

Â  Â  showGameModeSelection() {
Â  Â  Â  Â  hideAllSections();
Â  Â  Â  Â  hideFooter();
Â  Â  Â  Â  document.getElementById('multiplayerFooter').style.display = 'none';
Â  Â  Â  Â  document.getElementById('gameModeSection').style.display = '';
Â  Â  },

Â  Â  toggleLobbyView() {
Â  Â  Â  Â  const joinGameView = document.getElementById('joinGameView');
Â  Â  Â  Â  const createGameView = document.getElementById('createGameView');
Â  Â  Â  Â  const toggleBtn = document.getElementById('toggleLobbyViewBtn');

Â  Â  Â  Â  if (this.currentLobbyView === 'joinGame') {
Â  Â  Â  Â  Â  Â  this.currentLobbyView = 'createGame';
Â  Â  Â  Â  Â  Â  joinGameView.style.display = 'none';
Â  Â  Â  Â  Â  Â  createGameView.style.display = 'block';
Â  Â  Â  Â  Â  Â  toggleBtn.textContent = 'Ver Partidas Abertas';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  this.currentLobbyView = 'joinGame';
Â  Â  Â  Â  Â  Â  joinGameView.style.display = 'block';
Â  Â  Â  Â  Â  Â  createGameView.style.display = 'none';
Â  Â  Â  Â  Â  Â  toggleBtn.textContent = 'Criar Nova Partida';
Â  Â  Â  Â  }
Â  Â  },

Â  Â  showMultiplayerLobby() {
Â  Â  Â  Â  hideAllSections();
Â  Â  Â  Â  document.getElementById('multiplayerLobbySection').style.display = 'block';
Â  Â  Â  Â  this.currentLobbyView = 'createGame';
Â  Â  Â  Â  this.toggleLobbyView();
Â  Â  },

Â  Â  goToCreateGame() {
Â  Â  Â  Â  handleCreateGameClick();
Â  Â  },

Â  Â  showExerciseStatus() {
Â  Â  Â  Â  document.getElementById('exerciseStatus').classList.remove('hidden');
Â  Â  Â  Â  this.updateProgressBadge();
Â  Â  },

Â  Â  hideExerciseStatus() {
Â  Â  Â  Â  document.getElementById('exerciseStatus').classList.add('hidden');
Â  Â  },

Â  Â  updateProgressBadge() {
Â  Â  Â  Â  const badge = document.getElementById('progressBadge');
Â  Â  Â  Â  if (subtitles.length > 0) {
Â  Â  Â  Â  Â  Â  badge.textContent = `VocÃª: ${currentIndex + 1}/${subtitles.length}`;
Â  Â  Â  Â  }
Â  Â  },

Â  Â  showLessonSelection() {
Â  Â  Â  Â  hideAllSections();
Â  Â  Â  Â  document.getElementById('avulsas-section').style.display = '';
Â  Â  Â  Â  generateVideoCards(AppData.lessons.avulsas, 'avulsas-grid', handleLessonClick);
Â  Â  Â  Â  showFooter();
Â  Â  },

Â  Â  pauseAllResources() {
Â  Â  Â  Â  this.pauseVideo();
Â  Â  Â  Â  this.stopTimers();
Â  Â  Â  Â  this.resetExerciseState();
Â  Â  },

Â  Â  pauseVideo() {
Â  Â  Â  Â  const video = document.getElementById('video');
Â  Â  Â  Â  if (video && !video.paused) {
Â  Â  Â  Â  Â  Â  video.pause();
Â  Â  Â  Â  Â  Â  console.log('ğŸ¬ VÃ­deo pausado pela navegaÃ§Ã£o');
Â  Â  Â  Â  }
Â  Â  },

Â  Â  stopTimers() {
Â  Â  Â  Â  if (timerInterval) {
Â  Â  Â  Â  Â  Â  clearInterval(timerInterval);
Â  Â  Â  Â  Â  Â  timerInterval = null;
Â  Â  Â  Â  Â  Â  console.log('â±ï¸ Timer de performance interrompido');
Â  Â  Â  Â  }
Â  Â  },

Â  Â  resetExerciseState() {
Â  Â  Â  Â  formedWords = [];
Â  Â  Â  Â  currentIndex = 0;
Â  Â  Â  Â  startTime = 0;
Â  Â  Â  Â  totalElapsedTime = 0;
Â  Â  Â  Â  totalEstimatedTime = 0;

Â  Â  Â  Â  const timerElement = document.getElementById('timer');
Â  Â  Â  Â  if (timerElement) {
Â  Â  Â  Â  Â  Â  timerElement.innerHTML = '';
Â  Â  Â  Â  }
Â  Â  },

Â  Â  getLessonSelectionTitle() {
Â  Â  Â  Â  const mode = currentGameMode ?
Â  Â  Â  Â  Â  Â  currentGameMode.charAt(0).toUpperCase() + currentGameMode.slice(1) :
Â  Â  Â  Â  Â  Â  '';
Â  Â  Â  Â  const category = localStorage.getItem('lastLessonCategory') || 'avulsas';
Â  Â  Â  Â  const categoryName = category.charAt(0).toUpperCase() + category.slice(1);

Â  Â  Â  Â  return `${mode} - ${categoryName}`;
Â  Â  },

Â  Â  // NOVO: Adicione um mÃ©todo para exibir a tela de espera.
Â  Â  showWaitingScreen(lessonName) {
Â  Â  Â  Â  this.navigateTo('waitingScreen', false);
Â  Â  Â  Â  hideAllSections();
Â  Â  Â  Â  const waitingScreen = document.getElementById('waitingScreen');
Â  Â  Â  Â  if (!waitingScreen) {
Â  Â  Â  Â  Â  Â  console.error("Elemento 'waitingScreen' nÃ£o encontrado no HTML.");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  waitingScreen.style.display = 'flex';
Â  Â  Â  Â  this.updateWaitingScreenStatus(`Preparando a liÃ§Ã£o: <strong>${lessonName}</strong>`);
Â  Â  },
Â  Â  
Â  Â  // NOVO: Adicione um mÃ©todo para ocultar a tela de espera.
Â  Â  hideWaitingScreen() {
Â  Â  Â  Â  const waitingScreen = document.getElementById('waitingScreen');
Â  Â  Â  Â  if (waitingScreen) {
Â  Â  Â  Â  Â  Â  waitingScreen.style.display = 'none';
Â  Â  Â  Â  }
Â  Â  },Â 

    showGameResultsSection() {
        hideAllSections(); // Usa nossa funÃ§Ã£o auxiliar para esconder tudo
        const resultsSection = document.getElementById('gameResultsSection');
        if (resultsSection) {
            resultsSection.style.display = ''; // Mostra a seÃ§Ã£o de resultados
        }
    },

Â  Â  updateWaitingScreenStatus(message) {
Â  Â  Â  Â  const statusElement = document.getElementById('waitingStatusMessage');
Â  Â  Â  Â  if (statusElement) {
Â  Â  Â  Â  Â  Â  statusElement.innerHTML = message;
Â  Â  Â  Â  }
Â  Â  }
};

//=============================
// Bloco de Ocultar/Mostrar seÃ§Ãµes
//=============================
function hideAllSections() {
    const sectionsToHide = [
        'gameModeSection',  // Adicionar esta linha
        'avulsas-section',
        'trilha-section',
        'videoSection',
        'formedSentenceSection',
        'shuffledWordsSection',
        'multiplayerLobbySection',
        'gameResultsSection'
    ];

    sectionsToHide.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });
}

//=============================
// FunÃ§Ã£o: Carrega e Processa o SRT
//=============================
async function loadSrt(url) {
    const res = await fetch(url);
    const text = await res.text();
    return parseSRT(text);
}

//=============================
// FunÃ§Ã£o: Parser SRT simples
//=============================
function parseSRT(srt) {
    const regex = /(\d+)\s+(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\s+([\s\S]*?)(?=\n{2,}|$)/g;
    let result = [];
    let match;
    while ((match = regex.exec(srt)) !== null) {
        result.push({
            index: Number(match[1]),
            start: timeToSeconds(match[2]),
            end: timeToSeconds(match[3]),
            text: match[4].replace(/\n/g, ' ').trim()
        });
    }
    return result;
}

//=============================
// FunÃ§Ã£o: Converte tempo SRT para segundos
//=============================
function timeToSeconds(time) {
    const [h, m, s] = time.replace(',', '.').split(':');
    return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);
}

//=============================
// FunÃ§Ã£o: Embaralha palavras
//=============================
function shuffleWords(text) {
    const words = text.split(' ');
    for (let i = words.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [words[i], words[j]] = [words[j], words[i]];
    }
    return words;
}

//=============================
// FunÃ§Ã£o: Exibe palavras embaralhadas
//=============================
function displayShuffledWords(words, original) {
    const container = document.getElementById('shuffledWords');
    container.innerHTML = '';
    formedWords = [];

    words.forEach(word => {
        const span = document.createElement('span');
        span.className = 'word';
        span.textContent = word;
        
        // Altera de .onclick para .addEventListener
        span.addEventListener('click', () => {
            handleWordClick(word, span, original);
        });
        
        container.appendChild(span);
    });

    updateFormedSentence();
}

//=============================
// FunÃ§Ã£o principal de clique
//=============================
function handleWordClick(word, element, original) {
    if (isCorrectWord(word, original)) {
        processCorrectWord(word, element);
        clearIncorrectWords();
        updateDisplay(); // Atualiza apÃ³s adicionar palavra correta
    } else {
        markWordAsIncorrect(element);
    }

    updateFormedSentence();
    checkIfSentenceIsComplete(original);
}

//=============================
// Verifica se palavra estÃ¡ correta
//=============================
function isCorrectWord(word, original) {
    const expectedWords = original.split(' ');
    const currentIndex = formedWords.length;
    return word === expectedWords[currentIndex];
}

//=============================
// Processa palavra correta
//=============================
function processCorrectWord(word, element) {
    formedWords.push(word);
    element.classList.add('correct');
    element.onclick = null;
}

//=============================
// Marca palavra incorreta (nÃ£o adiciona Ã  frase)
//=============================
function markWordAsIncorrect(element) {
    element.classList.add('incorrect');
}

//=============================
// Limpa marcaÃ§Ãµes incorretas
//=============================
function clearIncorrectWords() {
    const incorrectElements = document.querySelectorAll('.word.incorrect');
    incorrectElements.forEach(el => {
        el.classList.remove('incorrect');
    });
}

//=============================
// Verifica se frase estÃ¡ completa e correta
//=============================
async function checkIfSentenceIsComplete(original) {
    if (formedWords.join(' ') === original) {
        // Parar timer antes de qualquer aÃ§Ã£o
        NavigationController.stopTimers();
        
        const timeUsed = stopTimerAndGetElapsed();
        console.log(`â±ï¸ Tempo para essa frase: ${timeUsed.toFixed(2)}s`);

        // Toca o vÃ­deo e aguarda terminar
        console.log('ğŸ¬ Reproduzindo trecho da frase completada...');
        await playCurrentSubtitleAndWait();
        
        // Verificar se ainda estamos na seÃ§Ã£o de exercÃ­cio antes de continuar
        if (NavigationController.currentSection !== 'exercise') {
            console.log('âš ï¸ UsuÃ¡rio saiu do exercÃ­cio, interrompendo fluxo');
            return;
        }
        
        // SÃ³ depois que o vÃ­deo terminou, avanÃ§a
        if (currentIndex < subtitles.length - 1) {
            nextPhrase();
        } else {
            alert('ğŸ‰ Todas as frases completas! LiÃ§Ã£o finalizada.');
            displayTotalTime();
        }
    }
}

//=============================
// FunÃ§Ã£o: Atualiza frase formada
//=============================
function updateFormedSentence() {
    document.getElementById('formedSentence').textContent = formedWords.join(' ');
}

//=============================
// FunÃ§Ã£o: AvanÃ§a para prÃ³xima frase
//=============================
async function nextPhrase() { // Tornou-se async
    currentIndex++;
    console.log(`ğŸ“ AvanÃ§ando para frase ${currentIndex + 1}/${subtitles.length}`);
    
    if (currentIndex < subtitles.length) {
        await prepareCurrentSubtitle(); // Aguarda a preparaÃ§Ã£o completa (incluindo vÃ­deo)
    } else {
        alert("âœ… Fim das legendas!");
        displayTotalTime();
    }
}


//=============================
// FunÃ§Ã£o: Prepara legenda atual
//=============================
async function prepareCurrentSubtitle() { // Tornou-se async
    if (NavigationController.currentSection !== 'exercise') {
        console.log('âš ï¸ NÃ£o estamos mais no exercÃ­cio, cancelando preparaÃ§Ã£o');
        return;
    }

    const sub = subtitles[currentIndex];
    console.log(`ğŸ¬ Preparando frase ${currentIndex + 1}: "${sub.text}"`);
    
    // 1. Limpa o estado anterior e prepara a interface
    formedWords = [];
    NavigationController.stopTimers();
    const shuffled = shuffleWords(sub.text);
    displayShuffledWords(shuffled, sub.text);
    NavigationController.updateProgressBadge();

    // 2. Toca o trecho de vÃ­deo e AGUARDA sua conclusÃ£o
    console.log('â–¶ï¸ Reproduzindo trecho de introduÃ§Ã£o...');
    await playCurrentSubtitleAndWait();
    
    // Verifica se o usuÃ¡rio nÃ£o navegou para outra tela enquanto o vÃ­deo tocava
    if (NavigationController.currentSection !== 'exercise') {
        console.log('âš ï¸ UsuÃ¡rio saiu durante a introduÃ§Ã£o. Cancelando inÃ­cio do timer.');
        return;
    }

    // 3. SOMENTE AGORA, inicia o timer de performance do usuÃ¡rio
    console.log('â±ï¸ IntroduÃ§Ã£o finalizada. Iniciando timer do usuÃ¡rio AGORA.');
    startTimer();
    startPerformanceUpdate();
}

//=============================
// Inicia a contagem de tempo real e a atualizaÃ§Ã£o da performance
//=============================
function startPerformanceUpdate() {
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        updateDisplay();
    }, 1000);
}

//=============================
// FunÃ§Ã£o para atualizar o display da performance (Chamada por setInterval e click)
//=============================
function updateDisplay() {
    // Verificar se ainda estamos no exercÃ­cio
    if (NavigationController.currentSection !== 'exercise') {
        NavigationController.stopTimers();
        return;
    }

    const display = document.getElementById('timer');
    if (!display) return;

    const sub = subtitles[currentIndex];
    const sentenceEstimatedTime = getTimeLimitForSentence(sub.text);
    const elapsed = (performance.now() - startTime) / 1000;
    
    // Calcula a projeÃ§Ã£o: tempo jÃ¡ gasto + tempo restante baseado na performance atual
    const wordsCompleted = formedWords.length;
    const totalWords = sub.text.split(' ').length;
    
    let projectedTotalTime;
    if (wordsCompleted > 0) {
        const timePerCompletedWord = elapsed / wordsCompleted;
        const remainingWords = totalWords - wordsCompleted;
        projectedTotalTime = elapsed + (remainingWords * timePerCompletedWord);
    } else {
        // Se ainda nÃ£o completou nenhuma palavra, usa o tempo atual como base
        projectedTotalTime = elapsed * (totalWords / Math.max(1, wordsCompleted || 0.1));
    }
    
    // Calcula a performance: quanto melhor que o estimado
    let performanceValue = (sentenceEstimatedTime / projectedTotalTime) * 100;
    
    // Garante que nÃ£o seja infinito ou NaN
    if (!isFinite(performanceValue) || performanceValue > 1000) {
        performanceValue = 100;
    }

    let emoji = 'ğŸ‘';
    if (performanceValue < 75) {
        emoji = 'ğŸ¢';
    } else if (performanceValue < 100) {
        emoji = 'ğŸ¤”';
    } else if (performanceValue > 125) {
        emoji = 'ğŸš€';
    }

    display.innerHTML = `<span style="font-weight: bold; color: ${performanceValue >= 100 ? 'green' : 'red'};">${performanceValue.toFixed(2)}%</span> ${emoji}`;
}

//=============================
// Nova funÃ§Ã£o que reproduz o vÃ­deo e retorna uma Promise
//=============================
function playCurrentSubtitleAndWait() {
    const video = document.getElementById('video');
    const sub = subtitles[currentIndex];
    
    if (!video || !sub) {
        console.error('âŒ VÃ­deo ou legenda nÃ£o encontrados');
        return Promise.resolve();
    }

    return new Promise((resolve) => {
        console.log(`â–¶ï¸ Reproduzindo trecho: ${sub.start.toFixed(2)}s - ${sub.end.toFixed(2)}s`);
        
        // Para o vÃ­deo antes de reposicionar
        video.pause();
        video.currentTime = sub.start;
        
        // FunÃ§Ã£o para monitorar o fim do trecho
        function checkVideoEnd() {
            if (video.currentTime >= sub.end) {
                video.pause();
                console.log(`â¸ï¸ VÃ­deo pausado em ${sub.end.toFixed(2)}s - Prosseguindo...`);
                resolve();
            } else if (!video.paused) {
                if (typeof video.requestVideoFrameCallback === 'function') {
                    video.requestVideoFrameCallback(checkVideoEnd);
                } else {
                    requestAnimationFrame(checkVideoEnd);
                }
            }
        }
        
        // Inicia reproduÃ§Ã£o
        const playPromise = video.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log(`âœ… VÃ­deo iniciado em ${sub.start.toFixed(2)}s`);
                checkVideoEnd();
            }).catch(error => {
                console.error('âŒ Erro ao reproduzir vÃ­deo:', error);
                resolve(); // Resolve mesmo com erro para nÃ£o travar
            });
        } else {
            checkVideoEnd();
        }
    });
}

//=============================
// FunÃ§Ã£o principal que toca o vÃ­deo (usada pelo botÃ£o)
//=============================
function playCurrentSubtitle() {
    playCurrentSubtitleAndWait(); // NÃ£o precisa aguardar quando chamado pelo botÃ£o
}

//=============================
// Bloco de Timer (Revisado)
//=============================
function getTimeLimitForSentence(sentence) {
    const characterCount = sentence.trim().replace(/\s/g, '').length;
    const timePerCharacter = 0.2;
    return characterCount * timePerCharacter;
}

//=============================
// Inicia contagem de tempo real do usuÃ¡rio
//=============================
function startTimer() {
    startTime = performance.now();
}

//=============================
// Calcula tempo gasto em segundos
//=============================
function stopTimerAndGetElapsed() {
    const endTime = performance.now();
    const elapsed = (endTime - startTime) / 1000;
    totalElapsedTime += elapsed;
    return elapsed;
}

/**
 * Atualiza o estado visual do turno com base no modo de jogo.
 * @param {boolean} isPlayerTurn - True se for a vez do jogador local.
 */
function updateTurnStatus(isPlayerTurn) {
  const playerStatusEl = document.getElementById('playerStatus');
  const opponentStatusEl = document.getElementById('opponentStatus');

  if (currentGameMode === 'solo') {
    // No modo solo, o jogador estÃ¡ sempre ativo e o oponente nunca Ã© mostrado.
    if (playerStatusEl) {
      playerStatusEl.classList.remove('turn-waiting');
      playerStatusEl.classList.add('turn-active');
    }
    if (opponentStatusEl) {
      // Usar display: none Ã© mais seguro para garantir que nÃ£o ocupe espaÃ§o.
      opponentStatusEl.style.display = 'none';
    }
  } else { // Modo Multiplayer
    // Garante que o status do oponente seja visÃ­vel no modo multiplayer.
    if (opponentStatusEl) {
      opponentStatusEl.style.display = ''; // Remove o display: none se existir.
    }

    // Aplica as classes de turno para ambos.
    if (playerStatusEl) {
      playerStatusEl.classList.toggle('turn-active', isPlayerTurn);
      playerStatusEl.classList.toggle('turn-waiting', !isPlayerTurn);
    }
    if (opponentStatusEl) {
      opponentStatusEl.classList.toggle('turn-active', !isPlayerTurn);
      opponentStatusEl.classList.toggle('turn-waiting', isPlayerTurn);
    }
  }
}

//=============================
// Exibe o tempo total acumulado
//=============================
function displayTotalTime() {
    const totalPerformance = (totalEstimatedTime / totalElapsedTime) * 100;
    alert(`LiÃ§Ã£o completa! ğŸ
Tempo total: ${totalElapsedTime.toFixed(2)}s
Desempenho geral: ${totalPerformance.toFixed(2)}%`);
}

//=============================
// Bloco de Footer
//=============================
function showFooter() {
    const footer = document.querySelector('footer');
    if (footer) footer.style.display = 'block';
}

function hideFooter() {
    const footer = document.querySelector('footer');
    if (footer) footer.style.display = 'none';
}

function goToSearch() {
    // FunÃ§Ã£o para futuro desenvolvimento
    alert('ğŸ” FunÃ§Ã£o de pesquisa em desenvolvimento');
}

function goToLessonCategory(category) {
    if (!currentGameMode) return;

    if (NavigationController.currentSection === 'exercise') {
        NavigationController.pauseAllResources();
    }
    
    hideAllSections();
    
    const containerId = category === 'trilha' ? 'trilha-grid' : 'avulsas-grid';
    const lessonsData = category === 'trilha' ? AppData.lessons.trilha : AppData.lessons.avulsas;
    
    document.getElementById(`${category}-section`).style.display = '';
    generateVideoCards(lessonsData, containerId, handleLessonClick);
    
    localStorage.setItem('lastLessonCategory', category);
    NavigationController.updateHeader();
    
    if (NavigationController.currentSection !== 'lessonSelection') {
        NavigationController.navigateTo('lessonSelection', false);
    }
}

function handleCreateGameClick() {
  // 1. Navega para a seÃ§Ã£o de liÃ§Ãµes avulsas (lessonSelection)
  goToLessonCategory('avulsas');

  // 2. Esconde o botÃ£o de "Criar Partida"
  const createGameButton = document.getElementById('toggleLobbyViewBtn');
  if (createGameButton) {
    createGameButton.style.display = 'none';
  }

  // 3. Exibe o footer de liÃ§Ãµes
  const footer = document.querySelector('footer'); // Ou use o seletor que funciona para o seu footer
  if (footer) {
    footer.style.display = 'block'; // Garante que o footer serÃ¡ exibido
  }
}

//=========================
// Bloco lessons cards
//=========================
function createVideoCard(lesson, onClick) {
    const card = document.createElement('div');
    card.className = 'video-card';
    card.textContent = lesson.name;
    
    // Altera de .onclick para .addEventListener
    card.addEventListener('click', () => {
        onClick(lesson);
    });

    return card;
}

//==========================================
// Gera grid de cards dentro do container
//==========================================
function generateVideoCards(lessons, containerId, onClick) {
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = '';
    lessons.forEach(lesson => {
        const card = createVideoCard(lesson, onClick);
        container.appendChild(card);
    });
}

//==========================================
// Carrega liÃ§Ãµes nas seÃ§Ãµes correspondentes
//==========================================
function loadAllLessons() {
    generateVideoCards(AppData.lessons.avulsas, 'avulsas-grid', handleLessonClick);
    generateVideoCards(AppData.lessons.trilha, 'trilha-grid', handleLessonClick);
}

//==============================================
// Gerencia a visibilidade do status do oponente
//==============================================
const ExerciseUIConfig = {
    solo: {
        showOpponentStatus: false,
        playerIsActive: true
    },
    multiplayer: {
        showOpponentStatus: true,
        playerIsActive: false
    }
};

function updateExerciseUI() {
    // Altere 'UIConfig' para 'ExerciseUIConfig' aqui
    const config = ExerciseUIConfig[currentGameMode] || ExerciseUIConfig.solo; 
    
    const opponentStatusEl = document.getElementById('opponentStatus');
    if (opponentStatusEl) {
        if (config.showOpponentStatus) {
            opponentStatusEl.classList.remove('hidden');
        } else {
            opponentStatusEl.classList.add('hidden');
        }
    }
    
    updateTurnStatus(config.playerIsActive);
}

//=============================
// FunÃ§Ã£o de inicializaÃ§Ã£o comum
//=============================
async function prepareExerciseEnvironment(lesson) {
    // 1. Limpa o estado e prepara a interface
    NavigationController.resetExerciseState();
    NavigationController.updateProgressBadge();
    
    hideAllSections();
    hideFooter();
    
    const main = document.querySelector('main');
    main.style.maxWidth = '800px';
    main.style.margin = '0 auto';
    main.style.paddingTop = '20px';
    
    document.getElementById('videoSection').style.display = '';
    document.getElementById('formedSentenceSection').style.display = '';
    document.getElementById('shuffledWordsSection').style.display = '';

    // 2. Configura o header e a navegaÃ§Ã£o
    NavigationController.sectionConfig.exercise.title = lesson.name;
    NavigationController.navigateTo('exercise');
    NavigationController.showExerciseStatus();

    // 3. Carrega os recursos da liÃ§Ã£o
    const video = document.getElementById('video');
    video.src = lesson.videoUrl;
    
    try {
        subtitles = await loadSrt(lesson.srtUrl);
        if (subtitles.length === 0) {
            alert("Erro: NÃ£o foi possÃ­vel carregar as legendas.");
            NavigationController.goHome();
            return false; // Indica falha no carregamento
        }
    } catch (error) {
        console.error("Falha ao carregar ou processar o SRT:", error);
        alert("Ocorreu um erro ao carregar os dados da liÃ§Ã£o.");
        NavigationController.goHome();
        return false; // Indica falha no carregamento
    }

    totalEstimatedTime = subtitles.reduce((sum, sub) => sum + getTimeLimitForSentence(sub.text), 0);
    totalElapsedTime = 0;
    
    currentIndex = 0;
    
    return true; // Indica sucesso
}

//==================================================
// Roteador principal para o clique no card de liÃ§Ã£o
//==================================================
async function handleLessonClick(lesson) {
    console.log(`Iniciando liÃ§Ã£o "${lesson.name}" no modo: ${currentGameMode}`);

    if (currentGameMode === 'multiplayer') {
        initMultiplayerGame(lesson);
    } else {
        const environmentReady = await prepareExerciseEnvironment(lesson);
        if (environmentReady) {
            initSoloGame(lesson);
        }
    }
}

//=============================
// Inicia o jogo no modo Solo
//=============================
async function initSoloGame(lesson) {
    console.log(`Iniciando liÃ§Ã£o "${lesson.name}" no modo Solo`);
    
    // 1. Prepara o ambiente e carrega os recursos da liÃ§Ã£o
    const environmentReady = await prepareExerciseEnvironment(lesson);
    if (!environmentReady) {
        return; // Retorna se houver um erro de carregamento
    }
    
    // 2. Inicia o fluxo especÃ­fico do modo solo
    console.log(`â±ï¸ Tempo total estimado para a liÃ§Ã£o: ${totalEstimatedTime.toFixed(2)}s`);
    await prepareCurrentSubtitle();
}

//================================================
// FunÃ§Ã£o para o modo Multiplayer
//================================================
async function initMultiplayerGame(lesson) {
    console.log("Iniciando fluxo de criaÃ§Ã£o de partida multiplayer...");

    // Se o serviÃ§o nÃ£o estiver pronto, avise o usuÃ¡rio e saia.
    if (!MultiplayerService.isInitialized) {
        NavigationController.showWaitingScreen(lesson.name);
        NavigationController.updateWaitingScreenStatus("Aguarde, conectando ao servidor...");
        console.warn("MultiplayerService nÃ£o estÃ¡ inicializado. Tente novamente em instantes.");
        // NÃ£o retorna, permitindo que a tela de espera seja exibida
        // e o usuÃ¡rio tenha uma chance de tentar novamente.
        return; 
    }

    // A partir daqui, sabemos que o serviÃ§o estÃ¡ pronto.
    serverState.status = 'connecting';
    NavigationController.showWaitingScreen(lesson.name);
    NavigationController.updateWaitingScreenStatus("Procurando um oponente...");

    try {
        await MultiplayerService.joinMatch(lesson.name);
    } catch (error) {
        serverState.status = 'idle';
        console.error("Erro ao tentar entrar na partida:", error.message);
        NavigationController.updateWaitingScreenStatus("Erro: " + error.message);
        // Em vez de goHome() imediatamente, pode-se mostrar o erro na tela de espera
        // e o usuÃ¡rio pode voltar para a tela inicial manualmente.
        // Se preferir ir direto para a home, a linha abaixo estÃ¡ correta.
        NavigationController.goHome();
    }
}

//================================================
// Multiplayer Service - MÃ³dulo Appwrite Realtime
//================================================
const MultiplayerService = {
    client: null,
    realtime: null,
    user: null, 
    channel: null,
    isInitialized: false,

    async init() {
        this.client = new Appwrite.Client()
            .setEndpoint('https://nyc.cloud.appwrite.io/v1')
            .setProject('689f3d3a00095fde3112');

        try {
            this.user = await this.client.account.createAnonymousSession();
            this.realtime = new Appwrite.Realtime(this.client);
            this.isInitialized = true;
        } catch (error) {
            console.error('[Appwrite] Erro ao criar sessÃ£o anÃ´nima:', error);
            this.isInitialized = false;
            throw new Error("Falha ao conectar com o servidor. Por favor, tente novamente mais tarde.");
        }
    },
    
    // **NOVO** MÃ©todo para entrar em uma partida
    async joinMatch(lessonName) {
        // Usa o nome da liÃ§Ã£o para criar um canal Ãºnico para a partida
        this.channel = `lesson_${lessonName}_game_channel`;
        
        let opponentFound = false;
        
        // Assina o canal para ouvir eventos
        this.realtime.subscribe(this.channel, response => {
            const event = response.payload;
            console.log('[Appwrite Realtime] Mensagem recebida:', event);
            
            // Verifica se a mensagem veio de outro jogador
            if (event.type === 'playerJoined' && event.playerId !== this.user.$id) {
                if (!opponentFound) {
                    opponentFound = true;
                    // Oponente encontrado! Inicia o jogo com a liÃ§Ã£o e o ID do oponente.
                    serverState.opponent.id = event.playerId;
                    serverState.opponent.name = "Oponente"; // VocÃª pode adicionar mais dados no futuro
                    
                    console.log(`[Appwrite] Oponente ${serverState.opponent.id} encontrado! Iniciando jogo...`);
                    
                    // LÃ³gica para iniciar o jogo
                    NavigationController.hideWaitingScreen();
                    initSoloGame(AppData.lessons.avulsas[0]); // Por enquanto, usa a primeira liÃ§Ã£o como placeholder
                }
            }
        });

        // Envia uma mensagem para o canal para notificar outros jogadores sobre a sua chegada
        await this.sendMessage({
            type: 'playerJoined',
            playerId: this.user.$id
        });
        
        console.log(`[Appwrite] Assinado e mensagem enviada para o canal: ${this.channel}`);
    },

    // Envia uma mensagem para o canal do jogo
    async sendMessage(message) {
        if (!this.realtime || !this.channel) {
            throw new Error("Realtime ou canal nÃ£o estÃ¡ inicializado.");
        }
        await this.realtime.send(this.channel, message);
    },

    async cancelMatchmaking() {
        console.log('[Appwrite] Cancelando matchmaking...');
        // Verifica se hÃ¡ uma conexÃ£o ativa para fechar
        if (this.realtime && this.channel) {
            this.realtime.unsubscribe(this.channel);
            console.log(`[Appwrite] Desinscrito do canal: ${this.channel}`);
        }
        
        // Reinicia o estado
        this.channel = null;
        this.user = null; // Opcional, mas Ãºtil para limpar o estado
        this.realtime = null;
Â  Â  Â  Â  this.isInitialized = false; // <-- Adicione esta linha
    },
};

//=============================
// InicializaÃ§Ã£o
//=============================
document.addEventListener('DOMContentLoaded', async () => {
Â  Â  // Inicializa o serviÃ§o do Appwrite Realtime
Â  Â  try {
Â  Â  Â  Â  await MultiplayerService.init();
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Falha na inicializaÃ§Ã£o do MultiplayerService:", error);
Â  Â  Â  Â  // VocÃª pode adicionar aqui uma lÃ³gica para informar o usuÃ¡rio sobre o erro.
Â  Â  }

Â  Â  loadAllLessons();
Â  Â  hideFooter();
Â  Â  NavigationController.showGameModeSelection();
Â  Â  NavigationController.updateHeader();

    // â–¼â–¼â–¼ ADICIONE ESTE BLOCO DE CÃ“DIGO NO FINAL â–¼â–¼â–¼
    const testButton = document.getElementById('testResultsBtn');
    if (testButton) {
        testButton.addEventListener('click', () => {
            console.log('BotÃ£o de teste de resultados clicado. Navegando...');
            // Usamos a funÃ§Ã£o principal navigateTo, que cuida de tudo
            NavigationController.navigateTo('gameResults'); 
        });
    }
    // â–²â–²â–² FIM DO BLOCO NOVO â–²â–²â–²
});
</script>
</body>
</html>
