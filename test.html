<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpeedPhrase</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; padding: 20px; }
    .video-container, .words-container, .formed-sentence, .controls { margin-top: 20px; }
    .word { display: inline-block; margin: 5px; padding: 10px 15px; background: #eee; border-radius: 5px; cursor: pointer; }
    .word.correct { background-color: #c8f7c5; }
    .word.incorrect { background-color: #f7c5c5; }
    .formed-sentence { font-weight: bold; margin-top: 10px; }
    button { margin-top: 10px; padding: 10px 20px; }
    .video-grid-container {
      padding: 20px;
    }
    
    .hidden {
      display: none;
    }

    .video-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }

    .video-card {
      background: #fff;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      width: 200px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }

    .video-card:hover {
      transform: scale(1.03);
    }
    
    .video-container {
    text-align: center;
    margin-top: 20px;
    }
    
    #video {
        max-width: 100%;
        height: auto;
        width: 70%;
    }
    
    /* Adicione este CSS dentro da sua tag <style> */

    .status-line {
      display: flex; /* Alinha o texto e o √≠cone na mesma linha */
      align-items: center;
      gap: 8px; /* Espa√ßamento entre o √≠cone e o texto */
      font-weight: 500;
    }
    
    /* O pseudo-elemento ::before cria o √≠cone dinamicamente */
    .status-line::before {
      content: ''; /* √çcone vazio por padr√£o */
      font-size: 1.2em;
    }
    
    /* Classe para quando o turno est√° ATIVO */
    .status-line.turn-active {
      opacity: 1;
    }
    .status-line.turn-active::before {
      content: 'üü¢'; /* √çcone verde para turno ativo */
    }
    
    /* Classe para quando o turno est√° ESPERANDO (vez do oponente) */
    .status-line.turn-waiting {
      opacity: 0.6; /* Deixa o status um pouco apagado para indicar inatividade */
    }
    .status-line.turn-waiting::before {
      content: 'üî¥'; /* √çcone vermelho para turno em espera */
    }

  </style>
</head>
<body>

<main style="padding-bottom: 80px;">
  <!-- Header fixo com navega√ß√£o
  Por que esta abordagem √© profissional:
  ‚úÖ Separa√ß√£o de responsabilidades - Timer n√£o mistura com t√≠tulo 
  ‚úÖ Visual limpo - Badges discretos mas vis√≠veis 
  ‚úÖ Responsivo - Se adapta a diferentes tamanhos de tela 
  ‚úÖ Contextual - S√≥ aparece quando relevante
  ‚úÖ Padr√£o da ind√∫stria - Similar a apps como Duolingo, Khan Academy
  O timer fica como um badge verde elegante ao lado do progresso, mantendo o header profissional e organizados.
  -->
<header id="mainHeader" class="main-header">
  <nav class="header-nav">
    <button id="homeBtn" class="nav-button home-button" onclick="NavigationController.goHome()">
      <span class="nav-icon">üè†</span>
      <span class="nav-text">Home</span>
    </button>
    
    <button id="backBtn" class="nav-button back-button hidden" onclick="NavigationController.goBack()">
      <span class="nav-icon">‚Üê</span>
      <span class="nav-text">Voltar</span>
    </button>
    
    <div class="header-center">
      <h1 id="headerTitle" class="header-title">SpeedPhrase</h1>
      
      <div id="exerciseStatus" class="exercise-status hidden">
        
        <div id="playerStatus" class="status-line">
          <span id="progressBadge" class="progress-badge"></span>
          <span id="timer" class="timer-badge"></span>
        </div>
        
        <div id="opponentStatus" class="status-line hidden">
          <span id="opponentProgressBadge" class="progress-badge"></span>
          <span id="opponentTimer" class="timer-badge"></span>
        </div>
        
      </div>
    </div>

    
    <button id="settingsBtn" class="nav-button settings-button" onclick="NavigationController.openSettings()">
      <span class="nav-icon">‚öôÔ∏è</span>
    </button>
  </nav>
</header>
  
  <!-- Se√ß√£o de sele√ß√£o de modo de jogo -->
  <section id="gameModeSection" class="game-mode-container">
    <h2>Escolha o modo de jogo</h2>
    <div class="mode-buttons">
      <button class="mode-button" onclick="selectGameMode('solo')">
        <span class="mode-icon">üéØ</span>
        <span class="mode-title">Solo</span>
        <span class="mode-description">Jogue no seu pr√≥prio ritmo</span>
      </button>
      <button class="mode-button" onclick="selectGameMode('multiplayer')">
        <span class="mode-icon">üë•</span>
        <span class="mode-title">Multiplayer</span>
        <span class="mode-description">Desafie outros jogadores</span>
      </button>
    </div>
  </section>
  
  <section id="avulsas-section" class="video-grid-container hidden">
    <div id="avulsas-grid" class="video-grid"></div>
  </section>

  <section id="trilha-section" class="video-grid-container hidden">
    <div id="trilha-grid" class="video-grid"></div>
  </section>

<!-- ========================================================= -->
<!-- Bloco HTML para o Plugin Multiplayer (Lobby Unificado v3) -->
<!-- ========================================================= -->
<section id="multiplayerLobbySection" class="hidden" style="text-align: center;">

  <!-- Se√ß√£o para ENTRAR em partidas existentes (vis√≠vel por padr√£o) -->
  <div id="joinGameView">
    <button onclick="MultiplayerPlugin.toggleLobbyView()">Ou, Crie Sua Pr√≥pria Partida</button>
    <h2>Partidas Abertas</h2>
    <p>Entre em uma partida para desafiar outro jogador.</p>
    <div id="waitingGamesList" class="video-grid" style="margin-bottom: 20px;">
      <!-- Partidas abertas ser√£o injetadas aqui -->
    </div>
  </div>

  <!-- Se√ß√£o para CRIAR uma nova partida (oculta por padr√£o) -->
  <div id="createGameView" class="hidden">
    <button onclick="MultiplayerPlugin.toggleLobbyView()">Ver Partidas Abertas</button>
    <h2>Criar Nova Partida</h2>
    <p>Escolha uma li√ß√£o e aguarde um oponente.</p>
    <!-- As se√ß√µes de li√ß√µes existentes (avulsas/trilha) ser√£o mostradas aqui -->
  </div>

</section>

  <!-- Se√ß√£o do v√≠deo e controles -->
  <section id="videoSection" class="hidden" style="margin-top: 0;">
    <div class="video-container">
      <video id="video" width="70%" height="340" controls>
        <source src="https://f005.backblazeb2.com/file/Avulsas/Im_Gonna_Be_-_500_Miles.mp4" type="video/mp4" />
      </video>
    </div>
    <div class="controls" style="margin-top: 10px;">
      <button onclick="playCurrentSubtitle()">‚ñ∂Ô∏è Tocar trecho</button>
    </div>
  </section>

  <!-- Se√ß√£o da frase formada -->
  <section id="formedSentenceSection" class="hidden" style="margin-top: 20px;">
    <div class="formed-sentence" id="formedSentence"></div>
  </section>

  <!-- Se√ß√£o das palavras embaralhadas -->
  <section id="shuffledWordsSection" class="hidden" style="margin-top: 20px;">
    <div class="words-container" id="shuffledWords"></div>
  </section>
</main>

<footer class="hidden" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: #eee;
  padding: 10px;
  text-align: center;
  border-top: 1px solid #ccc;
  z-index: 1000;
">
  <nav>
    <button onclick="goToSearch()">üîç Pesquisar</button>
    <button onclick="goToAvulsas()">üìÇ Avulsas</button>
    <button onclick="goToTrilha()">üõ§Ô∏è Trilha</button>
  </nav>
</footer>

<script>
//=============================
// GameState - O objeto de estado centralizado
//=============================
const GameState = {
    // Estado da li√ß√£o
    subtitles: [],
    currentIndex: 0,
    formedWords: [],

    // Estado do jogo
    currentGameMode: null,
    currentLessonCategory: 'avulsas', // Nova propriedade

    // Estado do timer
    timer: {
        startTime: 0,
        totalElapsedTime: 0,
        totalEstimatedTime: 0,
        intervalId: null
    }
};

//=============================
// AppData - Dados Centralizados (CORRIGIDO)
//=============================
const AppData = {
    lessons: {
        avulsas: [{
            name: "Catbox - I'm Gonna Be - 500 Miles.mp4",
            srtUrl: "https://files.catbox.moe/wt145j.srt",
            videoUrl: "https://files.catbox.moe/8pzqza.mp4"
        }],
        trilha: [{
            name: "B.B. Chapter 1 - Welcome & Nationalities",
            videoUrl: "https://f005.backblazeb2.com/file/Avulsas/Im_Gonna_Be_-_500_Miles.mp4",
            srtUrl: "https://f005.backblazeb2.com/file/Avulsas/Im_Gonna_Be_-_500_Miles.srt"
        }]
    }
};

//=============================
// Game Mode Selection
//=============================
function selectGameMode(mode) {
    // Use o novo objeto de estado
    GameState.currentGameMode = mode;
    console.log(`Modo selecionado: ${GameState.currentGameMode}`);

    NavigationController.navigateTo('lessonSelection');
    NavigationController.showLessonSelection();
}

//=============================
// Navigation Controller
//=============================
const NavigationController = {
    currentSection: 'gameMode',
    navigationStack: [],

    // Simplificar configura√ß√µes - tratar li√ß√µes como estado √∫nico
    sectionConfig: {
        gameMode: {
            title: 'SpeedPhrase',
            showBack: false,
            showHome: true,
            showFooter: false
        },
        lessonSelection: {
            title: '',
            showBack: true,
            showHome: true,
            showFooter: true
        },
        exercise: {
            title: 'Exerc√≠cio',
            showBack: true,
            showHome: true,
            showFooter: false
        }
    },


    // incluir limpeza
    // controlar footer
    navigateTo(section, pushToStack = true) {
        if (pushToStack && this.currentSection !== section) {
            this.navigationStack.push(this.currentSection);
        }

        this.currentSection = section;
        this.updateHeader();

        // CORRE√á√ÉO: Mover a l√≥gica de visibilidade para c√°
        const config = this.sectionConfig[this.currentSection];
        if (config) {
            if (config.showFooter) {
                showFooter();
            } else {
                hideFooter();
            }
        }
    },

    // Nova fun√ß√£o para controlar footer
    updateFooterVisibility() {
        const config = this.sectionConfig[this.currentSection];
        if (config && config.showFooter) {
            showFooter();
        } else {
            hideFooter();
        }
    },

    // Voltar
    goBack() {
        if (this.navigationStack.length > 0) {
            const previousSection = this.navigationStack.pop();

            // Se a se√ß√£o anterior era a de sele√ß√£o de li√ß√µes,
            // exiba a categoria correta.
            if (previousSection === 'lessonSelection') {
                const lastCategory = GameState.currentLessonCategory || 'avulsas';
                showLessonCategory(lastCategory);
            } else {
                this.navigateToSection(previousSection);
            }
        }
    },

    // Modificar goHome para garantir limpeza completa
    goHome() {
        this.pauseAllResources();
        this.hideExerciseStatus();
        this.navigationStack = [];
        this.currentSection = 'gameMode';
        this.showGameModeSelection(); // Chama a fun√ß√£o que j√° limpa e exibe a tela correta
        this.updateHeader();
        hideFooter(); // Adiciona a chamada para esconder o footer
    },

    // Abrir configura√ß√µes
    openSettings() {
        alert('‚öôÔ∏è Configura√ß√µes em desenvolvimento');
    },

    // Atualizar header baseado na se√ß√£o atual
    updateHeader() {
        const config = this.sectionConfig[this.currentSection];
        if (!config) return;

        // Obter t√≠tulo din√¢mico para lessonSelection
        let title = config.title;
        if (this.currentSection === 'lessonSelection') {
            title = this.getLessonSelectionTitle();
        }

        // Atualizar t√≠tulo
        document.getElementById('headerTitle').textContent = title;

        // Mostrar/esconder bot√£o voltar
        const backBtn = document.getElementById('backBtn');
        if (config.showBack && this.navigationStack.length > 0) {
            backBtn.classList.remove('hidden');
        } else {
            backBtn.classList.add('hidden');
        }
    },

    // Navegar para se√ß√£o espec√≠fica
    navigateToSection(section) {
        switch (section) {
            case 'gameMode':
                this.showGameModeSelection();
                break;
            case 'lessonSelection':
                // Navega para a categoria de li√ß√µes correta
                showLessonCategory(GameState.currentLessonCategory || 'avulsas');
                break;
            default:
                this.showGameModeSelection();
        }
        this.currentSection = section;
        this.updateHeader();
        this.updateFooterVisibility();
    },

    // Mostrar sele√ß√£o de modo
    showGameModeSelection() {
        hideAllSections();
        hideFooter();
        document.getElementById('gameModeSection').style.display = '';
    },

    showExerciseStatus() {
        document.getElementById('exerciseStatus').classList.remove('hidden');
        this.updateProgressBadge();
    },

    hideExerciseStatus() {
        document.getElementById('exerciseStatus').classList.add('hidden');
    },

    // Atualiza o progresso no cabe√ßalho
    updateProgressBadge() {
        const badge = document.getElementById('progressBadge');
        // Usa o estado para o c√°lculo do progresso
        if (GameState.subtitles.length > 0) {
            badge.textContent = `Voc√™: ${GameState.currentIndex + 1}/${GameState.subtitles.length}`;
        }
    },

    // VERS√ÉO CORRETA (A SUA ORIGINAL)
    showLessonSelection() {
        // Agora, showLessonCategory() gerencia a exibi√ß√£o correta
        showLessonCategory(GameState.currentLessonCategory || 'avulsas');
    },

    // Pausar todos os recursos ativos
    pauseAllResources() {
        this.pauseVideo();
        this.stopTimers();
        this.resetExerciseState();
    },

    // Pausar v√≠deo
    pauseVideo() {
        const video = document.getElementById('video');
        if (video && !video.paused) {
            video.pause();
            console.log('üé¨ V√≠deo pausado pela navega√ß√£o');
        }
    },

    // Parar todos os timers
    stopTimers() {
        if (GameState.timer.intervalId) {
            clearInterval(GameState.timer.intervalId);
            GameState.timer.intervalId = null; // Boa pr√°tica: zera a ID
            console.log('‚è±Ô∏è Timer de performance interrompido');
        }
    },

    // Resetar estado do exerc√≠cio
    resetExerciseState() {
        // Limpa as propriedades do objeto de estado
        GameState.formedWords = [];
        GameState.currentIndex = 0;
        GameState.timer.startTime = 0;
        GameState.timer.totalElapsedTime = 0;
        GameState.timer.totalEstimatedTime = 0;

        const timerElement = document.getElementById('timer');
        if (timerElement) {
            timerElement.innerHTML = '';
        }
    },

    getLessonSelectionTitle() {
        const mode = GameState.currentGameMode ?
            GameState.currentGameMode.charAt(0).toUpperCase() + GameState.currentGameMode.slice(1) :
            '';
        // CORRE√á√ÉO: Usa o GameState para a categoria
        const category = GameState.currentLessonCategory || 'avulsas';
        const categoryName = category.charAt(0).toUpperCase() + category.slice(1);

        return `${mode} - ${categoryName}`;
    }
};

//=============================
// Fun√ß√£o: Carrega e Processa o SRT
//=============================
async function loadSrt(url) {
    const res = await fetch(url);
    const text = await res.text();
    return parseSRT(text);
}

//=============================
// Fun√ß√£o: Parser SRT simples
//=============================
function parseSRT(srt) {
    const regex = /(\d+)\s+(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\s+([\s\S]*?)(?=\n{2,}|$)/g;
    let result = [];
    let match;
    while ((match = regex.exec(srt)) !== null) {
        result.push({
            index: Number(match[1]),
            start: timeToSeconds(match[2]),
            end: timeToSeconds(match[3]),
            text: match[4].replace(/\n/g, ' ').trim()
        });
    }
    return result;
}

//=============================
// Fun√ß√£o: Converte tempo SRT para segundos
//=============================
function timeToSeconds(time) {
    const [h, m, s] = time.replace(',', '.').split(':');
    return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);
}

//=============================
// Fun√ß√£o: Embaralha palavras
//=============================
function shuffleWords(text) {
    const words = text.split(' ');
    for (let i = words.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [words[i], words[j]] = [words[j], words[i]];
    }
    return words;
}

//=============================
// Fun√ß√£o: Exibe palavras embaralhadas
//=============================
function displayShuffledWords(words, original) {
    const container = document.getElementById('shuffledWords');
    container.innerHTML = '';

    // CORRE√á√ÉO: Limpa o array de palavras formadas no GameState
    GameState.formedWords = [];

    words.forEach(word => {
        const span = document.createElement('span');
        span.className = 'word';
        span.textContent = word;
        span.onclick = () => handleWordClick(word, span, original);
        container.appendChild(span);
    });

    updateFormedSentence();
}

//=============================
// Fun√ß√£o principal de clique
//=============================
function handleWordClick(word, element, original) {
    if (isCorrectWord(word, original)) {
        processCorrectWord(word, element);
        clearIncorrectWords();
        updateDisplay(); // Atualiza ap√≥s adicionar palavra correta
    } else {
        markWordAsIncorrect(element);
    }

    updateFormedSentence();
    checkIfSentenceIsComplete(original);
}

//=============================
// Fun√ß√£o: Verifica se palavra est√° correta
//=============================
function isCorrectWord(word, original) {
    const expectedWords = original.split(' ');
    // Usa o estado para obter o √≠ndice atual da palavra
    const currentIndex = GameState.formedWords.length;
    return word === expectedWords[currentIndex];
}

//=============================
// Processa palavra correta
//=============================
function processCorrectWord(word, element) {
    // Adiciona a palavra ao estado
    GameState.formedWords.push(word);
    element.classList.add('correct');
    element.onclick = null;
}

//=============================
// Marca palavra incorreta (n√£o adiciona √† frase)
//=============================
function markWordAsIncorrect(element) {
    element.classList.add('incorrect');
}

//=============================
// Limpa marca√ß√µes incorretas
//=============================
function clearIncorrectWords() {
    const incorrectElements = document.querySelectorAll('.word.incorrect');
    incorrectElements.forEach(el => {
        el.classList.remove('incorrect');
    });
}

//==========================================
// Verifica se frase est√° completa e correta
//==========================================
async function checkIfSentenceIsComplete(original) {
    // Usa o estado para verificar se a frase foi completada
    if (GameState.formedWords.join(' ') === original) {
        // ... (resto da fun√ß√£o permanece igual)
    }
}

//=============================
// Fun√ß√£o: Atualiza frase formada
//=============================
function updateFormedSentence() {
    // Usa o estado para renderizar a frase
    document.getElementById('formedSentence').textContent = GameState.formedWords.join(' ');
}

//=============================
// Fun√ß√£o: Avan√ßa para pr√≥xima frase
//=============================
async function nextPhrase() {
    // Incrementa o √≠ndice no estado
    GameState.currentIndex++;
    console.log(`üìù Avan√ßando para frase ${GameState.currentIndex + 1}/${GameState.subtitles.length}`);

    // Usa o estado para verificar se h√° mais frases
    if (GameState.currentIndex < GameState.subtitles.length) {
        await prepareCurrentSubtitle();
    } else {
        alert("‚úÖ Fim das legendas!");
        displayTotalTime();
    }
}

//=============================
// Fun√ß√£o: Prepara legenda atual
//=============================
async function prepareCurrentSubtitle() {
    if (NavigationController.currentSection !== 'exercise') {
        console.log('‚ö†Ô∏è N√£o estamos mais no exerc√≠cio, cancelando prepara√ß√£o');
        return;
    }

    const sub = GameState.subtitles[GameState.currentIndex];
    console.log(`üé¨ Preparando frase ${GameState.currentIndex + 1}: "${sub.text}"`);

    // 1. Limpa o estado anterior e prepara a interface
    GameState.formedWords = [];
    NavigationController.stopTimers();
    const shuffled = shuffleWords(sub.text);
    displayShuffledWords(shuffled, sub.text);
    NavigationController.updateProgressBadge();

    // 2. Toca o trecho de v√≠deo e AGUARDA sua conclus√£o
    console.log('‚ñ∂Ô∏è Reproduzindo trecho de introdu√ß√£o...');
    await playCurrentSubtitleAndWait();

    // Verifica se o usu√°rio n√£o navegou para outra tela enquanto o v√≠deo tocava
    if (NavigationController.currentSection !== 'exercise') {
        console.log('‚ö†Ô∏è Usu√°rio saiu durante a introdu√ß√£o. Cancelando in√≠cio do timer.');
        return;
    }

    // 3. SOMENTE AGORA, inicia o timer de performance do usu√°rio
    console.log('‚è±Ô∏è Introdu√ß√£o finalizada. Iniciando timer do usu√°rio AGORA.');
    GameState.timer.startTime = performance.now();
    startPerformanceUpdate();
}

//=============================
// Fun√ß√£o para atualizar o display da performance (Chamada por setInterval e click)
//=============================
function updateDisplay() {
    // Verificar se ainda estamos no exerc√≠cio
    if (NavigationController.currentSection !== 'exercise') {
        NavigationController.stopTimers();
        return;
    }

    const display = document.getElementById('timer');
    if (!display) return;

    const sub = GameState.subtitles[GameState.currentIndex];
    const sentenceEstimatedTime = getTimeLimitForSentence(sub.text);
    const elapsed = (performance.now() - GameState.timer.startTime) / 1000;

    // Calcula a proje√ß√£o: tempo j√° gasto + tempo restante baseado na performance atual
    const wordsCompleted = GameState.formedWords.length;
    const totalWords = sub.text.split(' ').length;

    let projectedTotalTime;
    if (wordsCompleted > 0) {
        const timePerCompletedWord = elapsed / wordsCompleted;
        const remainingWords = totalWords - wordsCompleted;
        projectedTotalTime = elapsed + (remainingWords * timePerCompletedWord);
    } else {
        // Se ainda n√£o completou nenhuma palavra, usa o tempo atual como base
        projectedTotalTime = elapsed * (totalWords / Math.max(1, wordsCompleted || 0.1));
    }

    // Calcula a performance: quanto melhor que o estimado
    let performanceValue = (sentenceEstimatedTime / projectedTotalTime) * 100;

    // Garante que n√£o seja infinito ou NaN
    if (!isFinite(performanceValue) || performanceValue > 1000) {
        performanceValue = 100;
    }

    let emoji = 'üëç';
    if (performanceValue < 75) {
        emoji = 'üê¢';
    } else if (performanceValue < 100) {
        emoji = 'ü§î';
    } else if (performanceValue > 125) {
        emoji = 'üöÄ';
    }

    display.innerHTML = `<span style="font-weight: bold; color: ${performanceValue >= 100 ? 'green' : 'red'};">${performanceValue.toFixed(2)}%</span> ${emoji}`;
}

//=============================
// Nova fun√ß√£o que reproduz o v√≠deo e retorna uma Promise
//=============================
function playCurrentSubtitleAndWait() {
    const video = document.getElementById('video');
    const sub = GameState.subtitles[GameState.currentIndex];

    if (!video || !sub) {
        console.error('‚ùå V√≠deo ou legenda n√£o encontrados');
        return Promise.resolve();
    }

    return new Promise((resolve) => {
        console.log(`‚ñ∂Ô∏è Reproduzindo trecho: ${sub.start.toFixed(2)}s - ${sub.end.toFixed(2)}s`);

        // Para o v√≠deo antes de reposicionar
        video.pause();
        video.currentTime = sub.start;

        // Fun√ß√£o para monitorar o fim do trecho
        function checkVideoEnd() {
            if (video.currentTime >= sub.end) {
                video.pause();
                console.log(`‚è∏Ô∏è V√≠deo pausado em ${sub.end.toFixed(2)}s - Prosseguindo...`);
                resolve();
            } else if (!video.paused) {
                if (typeof video.requestVideoFrameCallback === 'function') {
                    video.requestVideoFrameCallback(checkVideoEnd);
                } else {
                    requestAnimationFrame(checkVideoEnd);
                }
            }
        }

        // Inicia reprodu√ß√£o
        const playPromise = video.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log(`‚úÖ V√≠deo iniciado em ${sub.start.toFixed(2)}s`);
                checkVideoEnd();
            }).catch(error => {
                console.error('‚ùå Erro ao reproduzir v√≠deo:', error);
                resolve(); // Resolve mesmo com erro para n√£o travar
            });
        } else {
            checkVideoEnd();
        }
    });
}

//=============================
// Fun√ß√£o principal que toca o v√≠deo (usada pelo bot√£o)
//=============================
function playCurrentSubtitle() {
    playCurrentSubtitleAndWait(); // N√£o precisa aguardar quando chamado pelo bot√£o
}

//=============================
// Bloco de Timer (Revisado)
//=============================
function getTimeLimitForSentence(sentence) {
    const characterCount = sentence.trim().replace(/\s/g, '').length;
    const timePerCharacter = 0.2;
    return characterCount * timePerCharacter;
}

/**
 * Atualiza o estado visual do turno com base no modo de jogo.
 * @param {boolean} isPlayerTurn - True se for a vez do jogador local.
 */
function updateTurnStatus(isPlayerTurn) {
    const playerStatusEl = document.getElementById('playerStatus');
    const opponentStatusEl = document.getElementById('opponentStatus');

    if (GameState.currentGameMode === 'solo') {
        // No modo solo, o jogador est√° sempre ativo e o oponente nunca √© mostrado.
        if (playerStatusEl) {
            playerStatusEl.classList.remove('turn-waiting');
            playerStatusEl.classList.add('turn-active');
        }
        if (opponentStatusEl) {
            // Usar display: none √© mais seguro para garantir que n√£o ocupe espa√ßo.
            opponentStatusEl.style.display = 'none';
        }
    } else { // Modo Multiplayer
        // Garante que o status do oponente seja vis√≠vel no modo multiplayer.
        if (opponentStatusEl) {
            opponentStatusEl.style.display = ''; // Remove o display: none se existir.
        }

        // Aplica as classes de turno para ambos.
        if (playerStatusEl) {
            playerStatusEl.classList.toggle('turn-active', isPlayerTurn);
            playerStatusEl.classList.toggle('turn-waiting', !isPlayerTurn);
        }
        if (opponentStatusEl) {
            opponentStatusEl.classList.toggle('turn-active', !isPlayerTurn);
            opponentStatusEl.classList.toggle('turn-waiting', isPlayerTurn);
        }
    }
}

//=============================
// Bloco de Timer (Refatorado)
//=============================
function startPerformanceUpdate() {
    clearInterval(GameState.timer.intervalId);
    GameState.timer.intervalId = setInterval(() => {
        updateDisplay();
    }, 1000);
}

function stopTimerAndGetElapsed() {
    const endTime = performance.now();
    const elapsed = (endTime - GameState.timer.startTime) / 1000;
    GameState.timer.totalElapsedTime += elapsed;
    return elapsed;
}

function displayTotalTime() {
    const totalPerformance = (GameState.timer.totalEstimatedTime / GameState.timer.totalElapsedTime) * 100;
    alert(`Li√ß√£o completa! üèÅ
Tempo total: ${GameState.timer.totalElapsedTime.toFixed(2)}s
Desempenho geral: ${totalPerformance.toFixed(2)}%`);
}

//=============================
// Fun√ß√£o: Exibe uma categoria de li√ß√µes
//=============================
function showLessonCategory(category) {
    if (!GameState.currentGameMode) return;

    // Pausa recursos se estiver saindo de um exerc√≠cio
    if (NavigationController.currentSection === 'exercise') {
        NavigationController.pauseAllResources();
    }

    // Mapeia a categoria para o ID da se√ß√£o
    const sectionId = category === 'trilha' ? 'trilha-section' : 'avulsas-section';
    const lessons = AppData.lessons[category];

    // Esconde todas as se√ß√µes e exibe apenas a correta
    hideAllSections();
    document.getElementById(sectionId).style.display = '';

    // Gera os cards da categoria correta
    generateVideoCards(lessons, `${category}-grid`, handleLessonClick);

    // Armazena a categoria no estado, n√£o no localStorage
    GameState.currentLessonCategory = category;

    // Navega para a tela de sele√ß√£o de li√ß√µes
    NavigationController.navigateTo('lessonSelection');
}

//=============================
// Bloco de Footer
//=============================
function showFooter() {
    const footer = document.querySelector('footer');
    if (footer) footer.style.display = 'block';
}

function hideFooter() {
    const footer = document.querySelector('footer');
    if (footer) footer.style.display = 'none';
}

function goToSearch() {
    // Fun√ß√£o para futuro desenvolvimento
    alert('üîç Fun√ß√£o de pesquisa em desenvolvimento');
}

//=============================
// Bloco de Ocultar/Mostrar se√ß√µes
//=============================
function hideAllSections() {
    const sectionsToHide = [
        'gameModeSection',
        'avulsas-section',
        'trilha-section',
        'videoSection',
        'formedSentenceSection',
        'shuffledWordsSection',
        'exerciseStatus', // Adicionado para esconder o status do exerc√≠cio
        'multiplayerLobbySection'
    ];

    sectionsToHide.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });

    // CORRE√á√ÉO: Esconde o bot√£o de tocar trecho que estava vis√≠vel
    const playButton = document.getElementById('playCurrentPhraseBtn');
    if (playButton) {
        playButton.style.display = 'none';
    }
}

//=========================
// Bloco lessons cards
//=========================
function createVideoCard(lesson, onClick) {
    const card = document.createElement('div');
    card.className = 'video-card';
    card.textContent = lesson.name;
    card.onclick = () => onClick(lesson);
    return card;
}

//==========================================
// Gera grid de cards dentro do container
//==========================================
function generateVideoCards(lessons, containerId, onClick) {
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = '';
    lessons.forEach(lesson => {
        const card = createVideoCard(lesson, onClick);
        container.appendChild(card);
    });
}

//==========================================
// Carrega li√ß√µes nas se√ß√µes correspondentes
//==========================================
function loadAllLessons() {
    generateVideoCards(AppData.lessons.avulsas, 'avulsas-grid', handleLessonClick);
    generateVideoCards(AppData.lessons.trilha, 'trilha-grid', handleLessonClick);
}

//=============================
// Clique no card de li√ß√£o
//=============================
async function handleLessonClick(lesson) {
    console.log(`Iniciando li√ß√£o "${lesson.name}" no modo: ${GameState.currentGameMode}`);

    // 1. Limpa o estado do exerc√≠cio IMEDIATAMENTE ao entrar na li√ß√£o.
    NavigationController.resetExerciseState();
    NavigationController.updateProgressBadge(); // E atualiza o display

    // 2. Prepara a interface para o modo de exerc√≠cio
    hideAllSections();
    hideFooter();

    const main = document.querySelector('main');
    main.style.maxWidth = '800px';
    main.style.margin = '0 auto';
    main.style.paddingTop = '20px';

    document.getElementById('videoSection').style.display = '';
    document.getElementById('formedSentenceSection').style.display = '';
    document.getElementById('shuffledWordsSection').style.display = '';

    // 3. Configura o header e a navega√ß√£o
    NavigationController.sectionConfig.exercise.title = lesson.name;
    NavigationController.navigateTo('exercise');
    NavigationController.showExerciseStatus();

    // 4. Gerencia a visibilidade do status do oponente
    if (GameState.currentGameMode === 'multiplayer') {
        document.getElementById('opponentStatus').classList.remove('hidden');
        updateTurnStatus(false); // Inicia com a vez do oponente
    } else {
        document.getElementById('opponentStatus').classList.add('hidden');
        updateTurnStatus(true); // Sempre a vez do jogador no modo solo
    }

    // 5. Carrega os recursos da li√ß√£o
    const video = document.getElementById('video');
    video.src = lesson.videoUrl;

    try {
        GameState.subtitles = await loadSrt(lesson.srtUrl);
        if (GameState.subtitles.length === 0) {
            alert("Erro: N√£o foi poss√≠vel carregar as legendas.");
            NavigationController.goHome();
            return;
        }
    } catch (error) {
        console.error("Falha ao carregar ou processar o SRT:", error);
        alert("Ocorreu um erro ao carregar os dados da li√ß√£o.");
        NavigationController.goHome();
        return;
    }

    // 6. Calcula e armazena o tempo estimado e o tempo total da li√ß√£o no estado
    GameState.timer.totalEstimatedTime = GameState.subtitles.reduce((sum, sub) => sum + getTimeLimitForSentence(sub.text), 0);
    GameState.timer.totalElapsedTime = 0;
    console.log(`‚è±Ô∏è Tempo total estimado para a li√ß√£o: ${GameState.timer.totalEstimatedTime.toFixed(2)}s`);

    // 7. Zera o √≠ndice da li√ß√£o no estado
    GameState.currentIndex = 0;

    // 8. Inicia a prepara√ß√£o da primeira frase
    await prepareCurrentSubtitle();
}

//=============================
// Inicializa√ß√£o
//=============================
document.addEventListener('DOMContentLoaded', () => {
    // Remove o carregamento de todas as li√ß√µes na inicializa√ß√£o.
    // O carregamento √© agora responsabilidade do `showLessonCategory`.

    // Apenas garante que a tela inicial √© a de sele√ß√£o de modo de jogo
    // e que nada al√©m dela est√° vis√≠vel.
    NavigationController.showGameModeSelection();
    NavigationController.updateHeader();
});

// Adicionar listener para quando a p√°gina √© fechada/recarregada
window.addEventListener('beforeunload', () => {
    NavigationController.pauseAllResources();
});

// Adicionar listener para visibilidade da p√°gina
document.addEventListener('visibilitychange', () => {
    if (document.hidden && NavigationController.currentSection === 'exercise') {
        NavigationController.pauseVideo();
    }
});
</script>
</body>
</html>
